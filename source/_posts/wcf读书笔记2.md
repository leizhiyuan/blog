title: WCF读书笔记(2)
tags:
  - C＃
  - WCF
  - 大学
  - 学习
  - 开发
  - 总结
  - 收藏
id: 1426
categories:
  - 学习笔记
date: 2012-09-06 22:09:48
---

**信道形状（Channel Shape）**

　　用来表述不同的消息交换模式对消息交换双方信道（信息交换的管道）的不同要求，有什么IOutputChannel IReplyChannel IDuplexChannel之类的。。

　　对于IReplyChannel，服务器返回一个RequestContext类型，作为请求和回复之间的一道桥梁，可以获取也可以返回消息。

**会话信道（Session Channel）**

　　从状态保持的角度，信道可以分为两种类型，Datagram Channel和Session Channel，前者不和客户端绑定，后者可以识别客户端。

　　对于WCF的信道层来说，信道管理器在客户端和服务端扮演不同的角色。服务端的信道管理器用于监听来自客户端的请求，而客户端的信道仅仅是单纯创建用于请求发送和回复接收的信道，因此服务端的消息管理器又称为信道监听器（Channel Listener），客户端的信道管理器则称之为信道工厂（Channel Factory）

**绑定元素（Binding Element）**

　　构成一个绑定对象的元素，绑定实现了通信的所有细节，通过创建信道栈实现对消息的交换，系统绑定是指服务于某种类型场景的绑定元素的有序集合。 包括什么BaseHttpBinding之类的。

　　**一个程序集**包括元数据，中间语言代码，和资源。程序集已经加载，将一直保存在内存中，直到应用程序域卸载。最好摒弃添加服务引用的服务调用方式，而是直接将包含服务契约的程序集部署到客户端。客户端以直接创建代理的方式进行调用。

　　WCF可以看成是适配器，是CLR类型和XML两个不同世界的纽带。

　　**依赖倒置原则**：即抽象不应该依赖细节，细节应该依赖于抽象；即要针对接口编程，不要对实现编程。高层模块不应该依赖低层模块。两个都应该依赖抽象。

　　契约关心的是我能做到。而不在于我如何做到。

**封送（Marshaling）**

　　解决跨应用程序域对象访问的问题，需要采用一种特别的机制，那就是封送。分为按值封送和按引用封送

　　按值封送实现了跨应用程序域的数据共享

　　按引用封送则实现了跨应用程序域的远程调用。

　　如果一个程序员频繁的使用复制粘贴编程。那就意味着设计需要重构