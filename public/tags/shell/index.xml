<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shell on bystander&#39;s blog</title>
    <link>https://leizhiyuan.github.io/tags/shell/</link>
    <description>Recent content in Shell on bystander&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 29 Mar 2014 10:31:31 +0000</lastBuildDate>
    
	<atom:link href="https://leizhiyuan.github.io/tags/shell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>linux编写定时任务</title>
      <link>https://leizhiyuan.github.io/2014/03/29/linux%E7%BC%96%E5%86%99%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Sat, 29 Mar 2014 10:31:31 +0000</pubDate>
      
      <guid>https://leizhiyuan.github.io/2014/03/29/linux%E7%BC%96%E5%86%99%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid>
      <description>linux中定时任务用来执行一些周期性的自动化的任务，比如有些人可能用来定期备份，也可能是定期检查一下特殊文件的签名，如果不一致，就报警，检测入侵。
cron是linux下的定时执行工具
这个工具的几个命令是这样的 /sbin/service crond start //启动服务
/sbin/service crond stop //关闭服务
/sbin/service crond restart //重启服务
/sbin/service crond reload //重新载入配置 注意，这几个服务都是要以root权限才能运行的，很多时候，只要我们可能只是一个低权限的用户，那么我们要执行一些定时任务的时候，可以这样做
直接通过这个命令来编辑，无需root用户 crontab 首先添加定时任务 crontab -e 打开之后按如下的格式编写 */1 * * * * ls &amp;gt;&amp;gt; /tmp/ls.txt 从左到右一次表示
分钟 一小时的第几分 0-59 小时 一天的第几小时 0-23 日期 一个月的的第几天 1-31 月份 一年的第几个月 1-12 周几 一周的第几天 0-6
/1表示每一天 /2表示每两天，直接*的话就表示每天/每小时这样
写完之后，wq保存退出
然后 crontab -l //列出当前的所有调度任务 可以看到自己的定时任务了，然后就不要做什么操作了，操作系统定时会读取配置的，编辑完成之后，我们的定时任务过一会就会生效了。
有时候，可能还要把结果信息和一些错误信息也写入 30 5 * * * ls &amp;gt;&amp;gt;/result/test 2&amp;gt;&amp;amp;1
注：2&amp;gt;&amp;amp;1 表示执行结果及错误信息。 这里就是说明天的5点50执行一次ls命令，并把结果追加到文件</description>
    </item>
    
    <item>
      <title>Unix sed实用教程系列目录</title>
      <link>https://leizhiyuan.github.io/2013/08/11/unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Sun, 11 Aug 2013 17:03:51 +0000</pubDate>
      
      <guid>https://leizhiyuan.github.io/2013/08/11/unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95/</guid>
      <description>本系列文章已经译完了，译自awk-sed@theunixschool,收获颇丰，作者没有将明白的我做了补充，并且尝试讲的更清楚，整理成系列索引，方便学习，开篇非译文,是我为了方便后面的理解写的一篇,感谢原作者的分享.有任何问题欢迎留言讨论.
 Unix sed实用教程开篇 [译]Unix sed实用教程第一篇–向文件中增加一行 [译]Unix sed实用教程第二篇–替换文件内容 [译]Unix sed实用教程第三篇–读写文件 [译]Unix sed实用教程第四篇–选择性打印 [译]Unix sed实用教程第五篇–替换文件内容续 [译]Unix sed实用教程第六篇–删除文件内容 [译]Unix sed实用教程第七篇–输出文件内容(10 Demo) [译]Unix sed实用教程第八篇–CSV文件操作  </description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第八篇–CSV文件操作</title>
      <link>https://leizhiyuan.github.io/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AF%87csv%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 11 Aug 2013 16:55:33 +0000</pubDate>
      
      <guid>https://leizhiyuan.github.io/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AF%87csv%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>本文作为sed使用教程的最后一篇，将比较全面的讲解如何操作csv文件，csv文件通过逗号分隔
示例文件如下： cat file Solaris,25,11 Ubuntu,31,2 Fedora,21,3 LinuxMint,45,4 RedHat,12,5 1.删除第一列 $ sed &amp;rsquo;s/[^,]*,//&amp;rsquo; file 25,11 31,2 21,3 45,4 12,5 s开启替换模式，当^符号在中括号里的时候，就是非的意思，也就是说[^,]匹配了所有不是逗号的一个字符，然后后面的星号表示0个或多个，然后是一个逗号，也就是匹配&amp;rdquo;xxxx,&amp;ldquo;替换为空
2.删除除过最后一列的其他所有 $ sed &amp;rsquo;s/.*,//&amp;rsquo; file 11 2 3 4 5 sed先匹配任意多个字符，然后匹配最后一个“,”这就直接把前面的都匹配完了。替换为空即可。
3.输出第一列 $ sed &amp;rsquo;s/,.*//&amp;rsquo; file Solaris Ubuntu Fedora LinuxMint RedHat 好理解把，先匹配第一列之后的逗号，然后是多个字符，然后替换为空
4.删除第二列 $ sed &amp;rsquo;s/,[^,]*,/,/&amp;rsquo; file Solaris,11 Ubuntu,2 Fedora,3 LinuxMint,4 RedHat,5 先匹配第一列之后的逗号，然后匹配一个或多个非逗号字符，这样就匹配了第二列的内容，然后再匹配一个逗号，我简化一下，比如该列是1，2，3，4，那么这一个匹配就是&amp;rdquo;,2,&amp;ldquo;，替换成一个逗号，就是1，3，4了
5.输出第二列 $ sed &amp;rsquo;s/[^,],([^,])./\1/&amp;rsquo; file 25 31 21 45 12 我们可以分析前两个斜线之间的内容 [^,],([^,]). 两个右斜线转移了括号，所以括号不是简单的符号，而是正则里的组的意义，圆括号的作用是对字符进行分组，并保存匹配的文本。这里先匹配非逗号的多个字符，然后一个逗号，然后再匹配第二列，并且第二列的匹配用括号括起来，然后匹配其他列，然后里面用\1来引用这个括号的内容，如果前面有两个括号，就可以使用\1或\2这样，分别表示第一个括号或第二个括号的匹配
6.输出最后一列是一位数字的行 $ sed -n &amp;lsquo;/.</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第七篇–输出文件内容(10 Demo)</title>
      <link>https://leizhiyuan.github.io/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%83%E7%AF%87%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B910-demo/</link>
      <pubDate>Sun, 11 Aug 2013 16:27:31 +0000</pubDate>
      
      <guid>https://leizhiyuan.github.io/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%83%E7%AF%87%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B910-demo/</guid>
      <description>之前已经学习过选择性打印输出了，本文将通过10个例子全面讲解文件输出的一些方法，主打p命令
首先看一下将使用的示例文件 $ cat file AIX Solaris Unix Linux HPUX 1.打印文件首行 $ sed -n &amp;lsquo;1p&amp;rsquo; file AIX 之前讲过了，-n取消默认的全部打印，p表示print，1就是行号了
2.输出最后一行 $ sed -n &amp;lsquo;$p&amp;rsquo; file HPUX 3.输出不匹配X的那些行 $ sed -n &amp;lsquo;/X/!p&amp;rsquo; file Solaris Unix Linux 也好理解，！表示非，就是说包含X匹配的不打印输出
4.输出包含u/x的那些行 $ sed -n &amp;lsquo;/[ux]/p&amp;rsquo; file Unix Linux 正则是强大的，这样就匹配了u/x
5.输出以x/X结尾的那些行 $ sed -n &amp;lsquo;/[xX]$/p&amp;rsquo; file AIX Unix Linux HPUX 这里$符号不再是匹配文件尾部，而是行尾，这是正则的规则
6.输出以A/L开头的行 $ sed -n &amp;lsquo;/^A|^L/p&amp;rsquo; file AIX Linux 前面也说过，^匹配了行首，A表示A匹配，然而|则是或者的意思，为什么要加\转义，是为了避免被解析成pipe管道，后面的就不解释了
7.隔行打印
n命令是输出当前行，然后读入下一行到pattern space的意思，这句命令是这么执行的，首先读入一行，然后通过n命令输出，然后通过n命令再读一行，然后把这行删除，就出现了隔行输出的效果
8.如何两行输出，隔两行再输出 $ sed &amp;rsquo;n;n;N;d&amp;rsquo; file AIX Solaris HPUX n;n; 命令呢输出了前两行，然后读入第三行到pattern space，N命令则对如下一行并与第三行合并，然后d命令删除pattern space中的内容，于是三四行被清空，然后读入56行，继续重复。就这样。作者这里给出的例子不直观，我举个例子，我的文件内容是 $ cat test.</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第六篇–删除文件内容</title>
      <link>https://leizhiyuan.github.io/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AD%E7%AF%87%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</link>
      <pubDate>Sat, 10 Aug 2013 13:15:38 +0000</pubDate>
      
      <guid>https://leizhiyuan.github.io/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AD%E7%AF%87%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</guid>
      <description>其实，删除和替换是由一些相同的，不过，这里我们单独列出来，通过25个例子穿插讲解sed删除文件的一些方法，使用的示例文件如下： $ cat file Cygwin Unix Linux Solaris AIX 1.删除第一行 $ sed &amp;lsquo;1d&amp;rsquo; file Unix Linux Solaris AIX d就是删除，1就是指第1行，记得哦，这不会影响到源文件，一般，做删除的时候一般要加-i参数，前面说过了 sed -i &amp;lsquo;1d&amp;rsquo; file 2.删除指定行，这里删除第3行 $ sed &amp;lsquo;3d&amp;rsquo; file Cygwin Unix Solaris AIX 3.删除最后一行 $ sed &amp;lsquo;$d&amp;rsquo; file Cygwin Unix Linux Solaris 4.删除范围行，这里删除2-4行 $ sed &amp;lsquo;2,4d&amp;rsquo; file Cygwin AIX 5.保留指定的行，这里保留2-4行 $ sed &amp;lsquo;2,4!d&amp;rsquo; file Unix Linux Solaris ！这个是对前面的2,4来操作，是非的意思，也就是不是2-4行的行，这样除去2-4行，其他的都删除了
6.删除第一行和最后一行 $ sed &amp;lsquo;1d;$d&amp;rsquo; file Unix Linux Solaris 分号隔开两个命令，你懂的，也可以删除第二行和第三行等等. &amp;rsquo;2d;3d&amp;rsquo;
7.删除以指定字符开头的行 $ sed &amp;lsquo;/^L/d&amp;rsquo; file Cygwin Unix Solaris AIX 这里就把以L开头的Linux这一行删除了</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第五篇–替换文件内容续</title>
      <link>https://leizhiyuan.github.io/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%BB%AD/</link>
      <pubDate>Sat, 10 Aug 2013 09:05:55 +0000</pubDate>
      
      <guid>https://leizhiyuan.github.io/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%BB%AD/</guid>
      <description>前面已经学习过替换文件内容了，本文我们学习一些更频繁使用的搜索替换操作.
示例文件使用： $ cat file RE01:EMP1:25:2500 RE02:EMP2:26:2650 RE03:EMP3:24:3500 RE04:EMP4:27:2900 1.替换每行开始的两个字母，这里用XX来替换 $ sed &amp;rsquo;s/^../XX/&amp;rsquo; file XX01:EMP1:25:2500 XX02:EMP2:26:2650 XX03:EMP3:24:3500 XX04:EMP4:27:2900 s代表substitute，前面说过了，^用来匹配行开头，.表示任意一个字符，两个..就是你懂的，
其实，不要^符号也是可以的，因为默认就是从开头开始匹配，如下也可以实现 sed &amp;rsquo;s/../XX/&amp;rsquo; file 2.删除每行开头的两个字符 $ sed &amp;rsquo;s/^..//&amp;rsquo; file 01:EMP1:25:2500 02:EMP2:26:2650 03:EMP3:24:3500 04:EMP4:27:2900 看到没有，后两个斜线之间没有内容，也就是用空字符来替换开头的两个字符，就实现了删除
3.要是想删除每行最后的两个字符呢 $ sed &amp;rsquo;s/..$//&amp;rsquo; file RE01:EMP1:25:25 RE02:EMP2:26:26 RE03:EMP3:24:35 RE04:EMP4:27:29 再次强调，$在不同的情况下表示不同的意思，这里匹配行尾，有时候也匹配文件尾部
4.向每行末尾添加内容 $ sed &amp;rsquo;s/$/.Rs/&amp;rsquo; file RE01:EMP1:25:2500.Rs RE02:EMP2:26:2650.Rs RE03:EMP3:24:3500.Rs RE04:EMP4:27:2900.Rs 这里，先匹配行尾，然后把&amp;rdquo;.Rs&amp;rdquo;添加到行尾
5.在每行开头添加空格 $ sed &amp;rsquo;s/^/ /&amp;rsquo; file RE01:EMP1:25:Rs.2500 RE02:EMP2:26:Rs.2650 RE03:EMP3:24:Rs.3500 RE04:EMP4:27:Rs.2900 还记得前面说过的么，sed默认不影响原始文件，要是想更新原始文件，请加-i参数 $ sed -i &amp;rsquo;s/^/ /&amp;rsquo; file $ cat file RE01:EMP1:25:Rs.</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第四篇–选择性打印</title>
      <link>https://leizhiyuan.github.io/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AF%87%E9%80%89%E6%8B%A9%E6%80%A7%E6%89%93%E5%8D%B0/</link>
      <pubDate>Sat, 10 Aug 2013 08:39:56 +0000</pubDate>
      
      <guid>https://leizhiyuan.github.io/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AF%87%E9%80%89%E6%8B%A9%E6%80%A7%E6%89%93%E5%8D%B0/</guid>
      <description>本文，我们将会学习如何选择性的打印（其实，这里的打印是print，也就是输出到标准输出的意思），用到的示例文件是： $ cat file Gmail 10 Yahoo 20 Redif 18 1.打印所有内容 $ sed &amp;ldquo; file Gmail 10 Yahoo 20 Redif 18 一对单引号，没有任何参数即可
2.如何打印包含Gmail的那一行.(grep也可以实现这个功能) $ sed &amp;lsquo;/Gmail/p&amp;rsquo; file Gmail 10 Gmail 10 Yahoo 20 Redif 18 在斜线里面，我们指定正则匹配模式，p的意思呢，就是print，打印的意思，也就是打印包含Gmail这一行，但是我们看到Gmail打印了两次，为什么，因为sed的默认行为是在解析完一行之后就把他输出出来，也就是对于Gmail这一行，先执行p解析，解析完成后再默认打印一次，就打印了两次，而其他的，没有命令解析，直接读入完成后输出即可。
如果得到期望的结果呢？ $ sed -n &amp;lsquo;/Gmail/p&amp;rsquo; file Gmail 10 -n参数会取消sed的默认打印行为，所以就ok了
3.删除包含Gmail的那一行。（grep -v也有同样的效果） $ sed &amp;rsquo;/Gmail/d&amp;rsquo; file Yahoo 20 Redif 18 d就是delete的意思，不多解释，
同样，要想删除某一指定的行 $ sed &amp;lsquo;1d&amp;rsquo; file Yahoo 20 Redif 18 4.打印直到模式匹配，这里我们从头一直打印到Yahoo $ sed &amp;rsquo;/Yahoo/q&amp;rsquo; file Gmail 10 Yahoo 20 q就是quit的意思，这条命令就是对于前面的行都没啥可解析的，执行默认的打印即可，一到碰到Yahoo这一行，打印完成，就停止，退出，因此，就是上面的了</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第三篇–读写文件</title>
      <link>https://leizhiyuan.github.io/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AF%87%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 09 Aug 2013 16:52:56 +0000</pubDate>
      
      <guid>https://leizhiyuan.github.io/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AF%87%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</guid>
      <description>本文将展示如何将文件内容读入到sed输出，同时包含如何将一个文件的部分内容写入到另一文件
一.文件读取
假定有两个文件，file1和file2，内容分别如下： $ cat file1 1apple 1banana 1mango $ cat file2 2orange 2strawberry sed有两个选项用来读写文件 r filename : 读取filename指定的文件内容 w filename : 将内容写入filename指定的文件 看例子：
1.在file1的每一行读完之后读取file2的内容 $ sed &amp;lsquo;r file2&amp;rsquo; file1 1apple 2orange 2strawberry 1banana 2orange 2strawberry 1mango 2orange 2strawberry r file2读取file2的所有内容，因此r之前没有知道那个行号或匹配，因此有了上面的输出，记住，sed的工作机制，每次读file1的一行，然后执行命令
2.如何在读取了file1的第一行之后将file2读入 $ sed &amp;lsquo;1r file2&amp;rsquo; file1 1apple 2orange 2strawberry 1banana 1mango r前面加个1就行了
3.当file1某行匹配了模式之后，读入file2 $ sed &amp;lsquo;/banana/r file2&amp;rsquo; file1 1apple 1banana 2orange 2strawberry 1mango sed逐行读入file1，然后判断该行是否匹配banana，如果匹配，就读入file2
4.当file1读取完成后读入file2，其实就是合并两个文件 $ sed &amp;lsquo;$r file2&amp;rsquo; file1 1apple 1banana 1mango 2orange 2strawberry 这里只是演示一下，其实cat file1 file2就可以完成合并</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第二篇–替换文件内容</title>
      <link>https://leizhiyuan.github.io/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</link>
      <pubDate>Fri, 09 Aug 2013 16:24:12 +0000</pubDate>
      
      <guid>https://leizhiyuan.github.io/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</guid>
      <description>上一节中-Unix sed实用教程第一篇–向文件中增加一行 学习了添加文件，本节讲解数据内容替换.
本节将使用sample1.txt文件作为示例，文件内容如下，都是些水果..： apple orange banana pappaya 1.向每一行的开头添加内容，这里我们添加“Fruit：” $ sed &amp;rsquo;s/^/Fruit: /&amp;rsquo; sample1.txt Fruit: apple Fruit: orange Fruit: banana Fruit: pappaya 解析：s代表substitution，也就是替换，s之后是要替换/匹配的内容，斜线/用来分隔s以及要替换的原始内容还有要替换的最终内容，而&amp;rsquo;^&amp;lsquo;符号是说一个正则，用来匹配每一行的开头，匹配成功后在开头加上&amp;rsquo;Fruit:&amp;lsquo;。
2.向每一行的行尾添加内容 $ sed &amp;rsquo;s/$/ Fruit/&amp;rsquo; sample1.txt apple Fruit orange Fruit banana Fruit pappaya Fruit 注意，这里的$和上一节的$符号表示的意义不同，这里则是表示行尾.
3.如何替换指定的字符，这里将小写a替换成大写A $ sed &amp;rsquo;s/a/A/&amp;rsquo; sample1.txt Apple orAnge bAnana pAppaya 注意，仅仅将每一行的第一个a替换了，不是所有，本例表示替换单个字符，你可以替换一个单词都是可以的.
4.如何替换行内所有的字符，用A替换a $ sed &amp;rsquo;s/a/A/g&amp;rsquo; sample1.txt Apple orAnge bAnAnA pAppAyA 注意，只是加了一个g选项，g为global的简写，就是全局，全部的意思。
5.如何替换第二次出现的a? $ sed &amp;rsquo;s/a/A/2&amp;rsquo; sample1.txt apple orange banAna pappAya 不使用g，而是使用数字来表示行内第几次出现的a，结果如上
6.如何替换第二次之后的所有a呢？ $ sed &amp;rsquo;s/a/A/2g&amp;rsquo; sample1.</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第一篇--向文件中增加一行</title>
      <link>https://leizhiyuan.github.io/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AF%87--%E5%90%91%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/</link>
      <pubDate>Fri, 09 Aug 2013 14:56:29 +0000</pubDate>
      
      <guid>https://leizhiyuan.github.io/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AF%87--%E5%90%91%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/</guid>
      <description>Unix sed实用教程第一讲，本系列第一篇，有任何问题欢迎留言讨论。
sed 是unix中最重要的编辑器之一，注意，有之一..支持多种编辑任务，本文将实现题目的功能实例
假定我们有一额文本文件，叫做empFile，包含了员工名字和员工id，如下： Hilesh, 1001 Bharti, 1002 Aparna, 1003 Harshal, 1004 Keyur, 1005 1.如何通过sed给文件添加标题行-“Employee, EmpId” $ sed &amp;lsquo;1i Employee, EmpId&amp;rsquo; empFile Employee, EmpId Hilesh, 1001 Bharti, 1002 Aparna, 1003 Harshal, 1004 Keyur, 1005 解释：数字1，是说只对第一行执行操作，i代表在insert（熟悉vim的同学应该知道，i会在当前字符的前面插入，a是在后面插入），因此，1i就表示在将Employee, EmpId插入到第一行之前，
然后，有了标题行的文件仅仅会输出到标准输出，源文件内容并不会改变，如果需要更新源文件，可以使用重定向输出到一个临时文件，然后移动到原始文件。如果Unix系统的sed是GUN版本的，sed会有一个-i选项，可以直接实现更新源文件，（如何查看版本，终端下输入sed &amp;ndash;version即可看到）下面先执行，再查看文件，发现已经多了标题行了 $ sed -i &amp;lsquo;1i Employee, EmpId&amp;rsquo; empFile $ cat empFile Employee, EmpId Hilesh, 1001 Bharti, 1002 Aparna, 1003 Harshal, 1004 Keyur, 1005 2.如何在标题行之后，也就是原始第一行之前添加一行横线&amp;ndash;“&amp;mdash;&amp;ndash;” $ sed -i &amp;lsquo;1a &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;rsquo; empFile $ cat empFile</description>
    </item>
    
    <item>
      <title>Unix sed实用教程开篇</title>
      <link>https://leizhiyuan.github.io/2013/08/09/unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E5%BC%80%E7%AF%87/</link>
      <pubDate>Fri, 09 Aug 2013 09:43:52 +0000</pubDate>
      
      <guid>https://leizhiyuan.github.io/2013/08/09/unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E5%BC%80%E7%AF%87/</guid>
      <description>已经看了一段时间的Linux Shell编程了,也能完成一些基本的使用，为了加深理解，恰好看到了The Unix School的一个sed&amp;amp;awk教程，不是简单的命令参数堆积，而是一个相当实用的系列，因此，希望能在几天内完成翻译.翻译过程不会逐字翻译，会穿插一些注释，包括自己的一些理解和其他的一些引用，作为开篇，简单说一下sed的工作机制，对后面的理解会有很大帮助。
sed是什么： &amp;gt; sed是一个非交互式的流编辑器（stream editor）。所谓非交互式，是指使用sed只能在命令行下输入编辑命令来编辑文本，然后在屏幕上查看输出；而所谓流编辑器，是指sed每次只从文件（或输入）读入一行，然后对该行进行指定的处理，并将结果输出到屏幕（除非取消了屏幕输出又没有显式地使用打印命令），接着读入下一行。整个文件像流水一样被逐行处理然后逐行输出。(via Walk in Mindfields ) sed工作机制：
sed维护两个缓冲区，pattern space和hold space，命令开始执行之前都为空。
pattern space缓冲区用于临时保存每次读取的一行的内容，大部分的匹配和替换等等操作都是针对pattern space中的内容进行的，因此不会对输入文件有任何影响,而hold space则作为后备缓冲区使用,除非指定了一些特殊的命令(例如D删除命令)，否则pattern space中的内容会在处理完一行之后清空，但hold space中的内容在处理完每一行时不会被删除。
也就是说pattern space相当于我们的内存，hold space相当于硬盘.处理的时候在内存里，处理过的就放回硬盘.(这是我的理解，有一点点不恰当，但是因此一些概念会比较好理解.)
具体来说，可以大致分为以下几步： &amp;gt; 1.首先，从标准输入流读取一行，移除换行符，然后存入pattern space中 &amp;gt; &amp;gt; 2.执行指定的命令,(每个命令都有一个可选的地址(可以是行号，也可能是一个正则表达式匹配)，这个地址作为一个执行命令前的测试，指定了需要对那些行进行操作。当前行只有匹配的情况下才会执行命令。） &amp;gt; &amp;gt; 3.当指定所有的命令都执行完了之后，pattern space内容就被处理过了，sed默认会将pattern space中的内容打印到标准输出中，移除的换行符也会打印出来。本行操作完成。 &amp;gt; &amp;gt; 4.然后sed会读取下一行的内容，再次执行相同的操作。直到行尾。 &amp;nbsp;
基本上最基础的理论就差不多了.主要是这个工作机制比较重要.后面从示例中慢慢加深理解.</description>
    </item>
    
  </channel>
</rss>